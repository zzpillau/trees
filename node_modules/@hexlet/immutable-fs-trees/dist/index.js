"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filter = exports.reduce = exports.map = exports.isDirectory = exports.isFile = exports.getName = exports.getMeta = exports.getChildren = exports.mkdir = exports.mkfile = void 0;

// @ts-check

/**
 * Make file node
 * @example
 * mkfile('config.json');
 * // {
 * //   name: 'config.json',
 * //   meta: {},
 * //   type: 'file',
 * // }
 *
 * mkfile('config.json', { size: 1200 });
 * // {
 * //   name: 'config.json',
 * //   meta: { size: 1200 },
 * //   type: 'file',
 * // }
 */
const mkfile = (name, meta = {}) => ({
  name,
  meta,
  type: 'file'
});
/**
 * Make directory node
 * @example
 * mkdir('etc');
 * // {
 * //   name: 'etc',
 * //   children: [],
 * //   meta: {},
 * //   type: 'directory',
 * // }
 *
 * mkdir('etc', [mkfile('config'), mkfile('hosts')], { owner: 'user' });
 * // {
 * //   name: 'etc',
 * //   children: [
 * //     { name: 'config', meta: {}, type: 'file' },
 * //     { name: 'hosts', meta: {}, type: 'file' }
 * //   ],
 * //   meta: { owner: 'user' },
 * //   type: 'directory',
 * // }
 */


exports.mkfile = mkfile;

const mkdir = (name, children = [], meta = {}) => ({
  name,
  children,
  meta,
  type: 'directory'
});
/**
 * Return children
 * @example
 * getChildren(mkdir('etc')); // []
 * getChildren(mkdir('etc', [mkfile('name')])); // [<file>]
 */


exports.mkdir = mkdir;

const getChildren = directory => directory.children;
/**
 * Return meta
 * @example
 * getMeta(mkfile('etc')); // {}
 * getMeta(mkfile('etc', { owner: 'root' })); // { owner: 'root' }
 */


exports.getChildren = getChildren;

const getMeta = node => node.meta;
/**
 * Return name
 * @example
 * getName(mkfile('etc')); // etc
 * getName(mkdir('/')); // /
 */


exports.getMeta = getMeta;

const getName = node => node.name;
/**
 * Check is node a file
 * @example
 * isFile(mkfile('config')); // true
 * isFile(mkdir('etc')); // false
 */


exports.getName = getName;

const isFile = node => node.type === 'file';
/**
 * Check is node a directory
 * @example
 * isDirectory(mkdir('etc')); // true
 * isDirectory(mkfile('config')); // false
 */


exports.isFile = isFile;

const isDirectory = node => node.type === 'directory';
/**
 * Map tree
 * @example
 * const tree = mkdir('etc', [mkfile('config'), mkfile('hosts')]);
 *
 * const callbackFn = (node) => {
 *   const { name } = node;
 *   const newName = name.toUpperCase();
 *   return { ...node, name: newName };
 * };
 *
 * map(callbackFn, tree);
 * // {
 * //   name: 'ETC',
 * //   children: [
 * //     { name: 'CONFIG', meta: {}, type: 'file' },
 * //     { name: 'HOSTS', meta: {}, type: 'file' }
 * //   ],
 * //   meta: {},
 * //   type: 'directory',
 * // }
 */


exports.isDirectory = isDirectory;

const map = (callbackFn, tree) => {
  const updatedNode = callbackFn(tree);
  return isDirectory(tree) ? { ...updatedNode,
    children: tree.children.map(n => map(callbackFn, n))
  } : updatedNode;
};
/**
 * Reduce tree
 * @example
 * const tree = mkdir('etc', [mkfile('config'), mkfile('hosts')]);
 *
 * reduce((acc) => acc + 1, tree, 0);
 * // 3
 *
 * reduce((acc, node) => [...acc, node.name], tree, []);
 * // ['etc', 'config', 'hosts']
 */


exports.map = map;

const reduce = (callbackFn, tree, acc) => {
  const newAcc = callbackFn(acc, tree);

  if (isFile(tree)) {
    return newAcc;
  }

  return tree.children.reduce((iAcc, n) => reduce(callbackFn, n, iAcc), newAcc);
};
/**
 * Filter tree
 * @example
 * const tree = mkdir('etc', [mkfile('CONFIG'), mkfile('hosts')]);
 *
 * const callbackFn = (node) => {
 *   const { name } = node;
 *   return name === name.toLowerCase();
 * };
 *
 * filter(callbackFn, tree);
 * // {
 * //   name: 'etc',
 * //   children: [
 * //     { name: 'hosts', meta: {}, type: 'file' }
 * //   ],
 * //   meta: {},
 * //   type: 'directory',
 * // }
 */


exports.reduce = reduce;

const filter = (callbackFn, tree) => {
  if (!callbackFn(tree)) {
    return null;
  }

  return isDirectory(tree) ? { ...tree,
    children: tree.children.map(n => filter(callbackFn, n)).filter(v => v)
  } : tree;
};

exports.filter = filter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJta2ZpbGUiLCJuYW1lIiwibWV0YSIsInR5cGUiLCJta2RpciIsImNoaWxkcmVuIiwiZ2V0Q2hpbGRyZW4iLCJkaXJlY3RvcnkiLCJnZXRNZXRhIiwibm9kZSIsImdldE5hbWUiLCJpc0ZpbGUiLCJpc0RpcmVjdG9yeSIsIm1hcCIsImNhbGxiYWNrRm4iLCJ0cmVlIiwidXBkYXRlZE5vZGUiLCJuIiwicmVkdWNlIiwiYWNjIiwibmV3QWNjIiwiaUFjYyIsImZpbHRlciIsInYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQk8sTUFBTUEsTUFBTSxHQUFHLENBQUNDLElBQUQsRUFBT0MsSUFBSSxHQUFHLEVBQWQsTUFBc0I7QUFDMUNELEVBQUFBLElBRDBDO0FBRTFDQyxFQUFBQSxJQUYwQztBQUcxQ0MsRUFBQUEsSUFBSSxFQUFFO0FBSG9DLENBQXRCLENBQWY7QUFNUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQk8sTUFBTUMsS0FBSyxHQUFHLENBQUNILElBQUQsRUFBT0ksUUFBUSxHQUFHLEVBQWxCLEVBQXNCSCxJQUFJLEdBQUcsRUFBN0IsTUFBcUM7QUFDeERELEVBQUFBLElBRHdEO0FBRXhESSxFQUFBQSxRQUZ3RDtBQUd4REgsRUFBQUEsSUFId0Q7QUFJeERDLEVBQUFBLElBQUksRUFBRTtBQUprRCxDQUFyQyxDQUFkO0FBT1A7Ozs7Ozs7Ozs7QUFNTyxNQUFNRyxXQUFXLEdBQUlDLFNBQUQsSUFBZUEsU0FBUyxDQUFDRixRQUE3QztBQUVQOzs7Ozs7Ozs7O0FBTU8sTUFBTUcsT0FBTyxHQUFJQyxJQUFELElBQVVBLElBQUksQ0FBQ1AsSUFBL0I7QUFFUDs7Ozs7Ozs7OztBQU1PLE1BQU1RLE9BQU8sR0FBSUQsSUFBRCxJQUFVQSxJQUFJLENBQUNSLElBQS9CO0FBRVA7Ozs7Ozs7Ozs7QUFNTyxNQUFNVSxNQUFNLEdBQUlGLElBQUQsSUFBVUEsSUFBSSxDQUFDTixJQUFMLEtBQWMsTUFBdkM7QUFFUDs7Ozs7Ozs7OztBQU1PLE1BQU1TLFdBQVcsR0FBSUgsSUFBRCxJQUFVQSxJQUFJLENBQUNOLElBQUwsS0FBYyxXQUE1QztBQUVQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCTyxNQUFNVSxHQUFHLEdBQUcsQ0FBQ0MsVUFBRCxFQUFhQyxJQUFiLEtBQXNCO0FBQ3ZDLFFBQU1DLFdBQVcsR0FBR0YsVUFBVSxDQUFDQyxJQUFELENBQTlCO0FBRUEsU0FBT0gsV0FBVyxDQUFDRyxJQUFELENBQVgsR0FDSCxFQUFFLEdBQUdDLFdBQUw7QUFBa0JYLElBQUFBLFFBQVEsRUFBRVUsSUFBSSxDQUFDVixRQUFMLENBQWNRLEdBQWQsQ0FBbUJJLENBQUQsSUFBT0osR0FBRyxDQUFDQyxVQUFELEVBQWFHLENBQWIsQ0FBNUI7QUFBNUIsR0FERyxHQUVIRCxXQUZKO0FBR0QsQ0FOTTtBQVFQOzs7Ozs7Ozs7Ozs7Ozs7QUFXTyxNQUFNRSxNQUFNLEdBQUcsQ0FBQ0osVUFBRCxFQUFhQyxJQUFiLEVBQW1CSSxHQUFuQixLQUEyQjtBQUMvQyxRQUFNQyxNQUFNLEdBQUdOLFVBQVUsQ0FBQ0ssR0FBRCxFQUFNSixJQUFOLENBQXpCOztBQUVBLE1BQUlKLE1BQU0sQ0FBQ0ksSUFBRCxDQUFWLEVBQWtCO0FBQ2hCLFdBQU9LLE1BQVA7QUFDRDs7QUFDRCxTQUFPTCxJQUFJLENBQUNWLFFBQUwsQ0FBY2EsTUFBZCxDQUFxQixDQUFDRyxJQUFELEVBQU9KLENBQVAsS0FBYUMsTUFBTSxDQUFDSixVQUFELEVBQWFHLENBQWIsRUFBZ0JJLElBQWhCLENBQXhDLEVBQStERCxNQUEvRCxDQUFQO0FBQ0QsQ0FQTTtBQVNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQk8sTUFBTUUsTUFBTSxHQUFHLENBQUNSLFVBQUQsRUFBYUMsSUFBYixLQUFzQjtBQUMxQyxNQUFJLENBQUNELFVBQVUsQ0FBQ0MsSUFBRCxDQUFmLEVBQXVCO0FBQ3JCLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU9ILFdBQVcsQ0FBQ0csSUFBRCxDQUFYLEdBQ0gsRUFBRSxHQUFHQSxJQUFMO0FBQVdWLElBQUFBLFFBQVEsRUFBRVUsSUFBSSxDQUFDVixRQUFMLENBQWNRLEdBQWQsQ0FBbUJJLENBQUQsSUFBT0ssTUFBTSxDQUFDUixVQUFELEVBQWFHLENBQWIsQ0FBL0IsRUFBZ0RLLE1BQWhELENBQXdEQyxDQUFELElBQU9BLENBQTlEO0FBQXJCLEdBREcsR0FFSFIsSUFGSjtBQUdELENBUk0iLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBNYWtlIGZpbGUgbm9kZVxuICogQGV4YW1wbGVcbiAqIG1rZmlsZSgnY29uZmlnLmpzb24nKTtcbiAqIC8vIHtcbiAqIC8vICAgbmFtZTogJ2NvbmZpZy5qc29uJyxcbiAqIC8vICAgbWV0YToge30sXG4gKiAvLyAgIHR5cGU6ICdmaWxlJyxcbiAqIC8vIH1cbiAqXG4gKiBta2ZpbGUoJ2NvbmZpZy5qc29uJywgeyBzaXplOiAxMjAwIH0pO1xuICogLy8ge1xuICogLy8gICBuYW1lOiAnY29uZmlnLmpzb24nLFxuICogLy8gICBtZXRhOiB7IHNpemU6IDEyMDAgfSxcbiAqIC8vICAgdHlwZTogJ2ZpbGUnLFxuICogLy8gfVxuICovXG5leHBvcnQgY29uc3QgbWtmaWxlID0gKG5hbWUsIG1ldGEgPSB7fSkgPT4gKHtcbiAgbmFtZSxcbiAgbWV0YSxcbiAgdHlwZTogJ2ZpbGUnLFxufSk7XG5cbi8qKlxuICogTWFrZSBkaXJlY3Rvcnkgbm9kZVxuICogQGV4YW1wbGVcbiAqIG1rZGlyKCdldGMnKTtcbiAqIC8vIHtcbiAqIC8vICAgbmFtZTogJ2V0YycsXG4gKiAvLyAgIGNoaWxkcmVuOiBbXSxcbiAqIC8vICAgbWV0YToge30sXG4gKiAvLyAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICogLy8gfVxuICpcbiAqIG1rZGlyKCdldGMnLCBbbWtmaWxlKCdjb25maWcnKSwgbWtmaWxlKCdob3N0cycpXSwgeyBvd25lcjogJ3VzZXInIH0pO1xuICogLy8ge1xuICogLy8gICBuYW1lOiAnZXRjJyxcbiAqIC8vICAgY2hpbGRyZW46IFtcbiAqIC8vICAgICB7IG5hbWU6ICdjb25maWcnLCBtZXRhOiB7fSwgdHlwZTogJ2ZpbGUnIH0sXG4gKiAvLyAgICAgeyBuYW1lOiAnaG9zdHMnLCBtZXRhOiB7fSwgdHlwZTogJ2ZpbGUnIH1cbiAqIC8vICAgXSxcbiAqIC8vICAgbWV0YTogeyBvd25lcjogJ3VzZXInIH0sXG4gKiAvLyAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICogLy8gfVxuICovXG5leHBvcnQgY29uc3QgbWtkaXIgPSAobmFtZSwgY2hpbGRyZW4gPSBbXSwgbWV0YSA9IHt9KSA9PiAoe1xuICBuYW1lLFxuICBjaGlsZHJlbixcbiAgbWV0YSxcbiAgdHlwZTogJ2RpcmVjdG9yeScsXG59KTtcblxuLyoqXG4gKiBSZXR1cm4gY2hpbGRyZW5cbiAqIEBleGFtcGxlXG4gKiBnZXRDaGlsZHJlbihta2RpcignZXRjJykpOyAvLyBbXVxuICogZ2V0Q2hpbGRyZW4obWtkaXIoJ2V0YycsIFtta2ZpbGUoJ25hbWUnKV0pKTsgLy8gWzxmaWxlPl1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENoaWxkcmVuID0gKGRpcmVjdG9yeSkgPT4gZGlyZWN0b3J5LmNoaWxkcmVuO1xuXG4vKipcbiAqIFJldHVybiBtZXRhXG4gKiBAZXhhbXBsZVxuICogZ2V0TWV0YShta2ZpbGUoJ2V0YycpKTsgLy8ge31cbiAqIGdldE1ldGEobWtmaWxlKCdldGMnLCB7IG93bmVyOiAncm9vdCcgfSkpOyAvLyB7IG93bmVyOiAncm9vdCcgfVxuICovXG5leHBvcnQgY29uc3QgZ2V0TWV0YSA9IChub2RlKSA9PiBub2RlLm1ldGE7XG5cbi8qKlxuICogUmV0dXJuIG5hbWVcbiAqIEBleGFtcGxlXG4gKiBnZXROYW1lKG1rZmlsZSgnZXRjJykpOyAvLyBldGNcbiAqIGdldE5hbWUobWtkaXIoJy8nKSk7IC8vIC9cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5hbWUgPSAobm9kZSkgPT4gbm9kZS5uYW1lO1xuXG4vKipcbiAqIENoZWNrIGlzIG5vZGUgYSBmaWxlXG4gKiBAZXhhbXBsZVxuICogaXNGaWxlKG1rZmlsZSgnY29uZmlnJykpOyAvLyB0cnVlXG4gKiBpc0ZpbGUobWtkaXIoJ2V0YycpKTsgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRmlsZSA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09ICdmaWxlJztcblxuLyoqXG4gKiBDaGVjayBpcyBub2RlIGEgZGlyZWN0b3J5XG4gKiBAZXhhbXBsZVxuICogaXNEaXJlY3RvcnkobWtkaXIoJ2V0YycpKTsgLy8gdHJ1ZVxuICogaXNEaXJlY3RvcnkobWtmaWxlKCdjb25maWcnKSk7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RpcmVjdG9yeSA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09ICdkaXJlY3RvcnknO1xuXG4vKipcbiAqIE1hcCB0cmVlXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJlZSA9IG1rZGlyKCdldGMnLCBbbWtmaWxlKCdjb25maWcnKSwgbWtmaWxlKCdob3N0cycpXSk7XG4gKlxuICogY29uc3QgY2FsbGJhY2tGbiA9IChub2RlKSA9PiB7XG4gKiAgIGNvbnN0IHsgbmFtZSB9ID0gbm9kZTtcbiAqICAgY29uc3QgbmV3TmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAqICAgcmV0dXJuIHsgLi4ubm9kZSwgbmFtZTogbmV3TmFtZSB9O1xuICogfTtcbiAqXG4gKiBtYXAoY2FsbGJhY2tGbiwgdHJlZSk7XG4gKiAvLyB7XG4gKiAvLyAgIG5hbWU6ICdFVEMnLFxuICogLy8gICBjaGlsZHJlbjogW1xuICogLy8gICAgIHsgbmFtZTogJ0NPTkZJRycsIG1ldGE6IHt9LCB0eXBlOiAnZmlsZScgfSxcbiAqIC8vICAgICB7IG5hbWU6ICdIT1NUUycsIG1ldGE6IHt9LCB0eXBlOiAnZmlsZScgfVxuICogLy8gICBdLFxuICogLy8gICBtZXRhOiB7fSxcbiAqIC8vICAgdHlwZTogJ2RpcmVjdG9yeScsXG4gKiAvLyB9XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoY2FsbGJhY2tGbiwgdHJlZSkgPT4ge1xuICBjb25zdCB1cGRhdGVkTm9kZSA9IGNhbGxiYWNrRm4odHJlZSk7XG5cbiAgcmV0dXJuIGlzRGlyZWN0b3J5KHRyZWUpXG4gICAgPyB7IC4uLnVwZGF0ZWROb2RlLCBjaGlsZHJlbjogdHJlZS5jaGlsZHJlbi5tYXAoKG4pID0+IG1hcChjYWxsYmFja0ZuLCBuKSkgfVxuICAgIDogdXBkYXRlZE5vZGU7XG59O1xuXG4vKipcbiAqIFJlZHVjZSB0cmVlXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJlZSA9IG1rZGlyKCdldGMnLCBbbWtmaWxlKCdjb25maWcnKSwgbWtmaWxlKCdob3N0cycpXSk7XG4gKlxuICogcmVkdWNlKChhY2MpID0+IGFjYyArIDEsIHRyZWUsIDApO1xuICogLy8gM1xuICpcbiAqIHJlZHVjZSgoYWNjLCBub2RlKSA9PiBbLi4uYWNjLCBub2RlLm5hbWVdLCB0cmVlLCBbXSk7XG4gKiAvLyBbJ2V0YycsICdjb25maWcnLCAnaG9zdHMnXVxuICovXG5leHBvcnQgY29uc3QgcmVkdWNlID0gKGNhbGxiYWNrRm4sIHRyZWUsIGFjYykgPT4ge1xuICBjb25zdCBuZXdBY2MgPSBjYWxsYmFja0ZuKGFjYywgdHJlZSk7XG5cbiAgaWYgKGlzRmlsZSh0cmVlKSkge1xuICAgIHJldHVybiBuZXdBY2M7XG4gIH1cbiAgcmV0dXJuIHRyZWUuY2hpbGRyZW4ucmVkdWNlKChpQWNjLCBuKSA9PiByZWR1Y2UoY2FsbGJhY2tGbiwgbiwgaUFjYyksIG5ld0FjYyk7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0cmVlXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJlZSA9IG1rZGlyKCdldGMnLCBbbWtmaWxlKCdDT05GSUcnKSwgbWtmaWxlKCdob3N0cycpXSk7XG4gKlxuICogY29uc3QgY2FsbGJhY2tGbiA9IChub2RlKSA9PiB7XG4gKiAgIGNvbnN0IHsgbmFtZSB9ID0gbm9kZTtcbiAqICAgcmV0dXJuIG5hbWUgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAqIH07XG4gKlxuICogZmlsdGVyKGNhbGxiYWNrRm4sIHRyZWUpO1xuICogLy8ge1xuICogLy8gICBuYW1lOiAnZXRjJyxcbiAqIC8vICAgY2hpbGRyZW46IFtcbiAqIC8vICAgICB7IG5hbWU6ICdob3N0cycsIG1ldGE6IHt9LCB0eXBlOiAnZmlsZScgfVxuICogLy8gICBdLFxuICogLy8gICBtZXRhOiB7fSxcbiAqIC8vICAgdHlwZTogJ2RpcmVjdG9yeScsXG4gKiAvLyB9XG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSAoY2FsbGJhY2tGbiwgdHJlZSkgPT4ge1xuICBpZiAoIWNhbGxiYWNrRm4odHJlZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpc0RpcmVjdG9yeSh0cmVlKVxuICAgID8geyAuLi50cmVlLCBjaGlsZHJlbjogdHJlZS5jaGlsZHJlbi5tYXAoKG4pID0+IGZpbHRlcihjYWxsYmFja0ZuLCBuKSkuZmlsdGVyKCh2KSA9PiB2KSB9XG4gICAgOiB0cmVlO1xufTtcbiJdfQ==