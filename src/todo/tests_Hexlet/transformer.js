// Перед прохождением данного испытания рекомендуется пройти и проанализировать решение учителя в испытании "Построение маршрута".
// transformer.js

// Реализуйте и экспортируйте по умолчанию функцию, которая строит дерево относительно заданного корневого узла.

// Функция принимает 2 аргумента:

//     исходное дерево
//     узел, от которого будет построено новое дерево.

// Функция должна возвращать новое дерево с сохранёнными связями между узлами, в котором переданный узел является корневым.
// Примеры

const tree = [
  'A',
  [
    //     A
    [
      'B',
      [
        //    / \
        ['D'], //   B   C
      ],
    ], //  /   / \
    [
      'C',
      [
        // D   E   F
        ['E'],
        ['F'],
      ],
    ],
  ],
];

transform(tree, 'B');

// ['B', [           //   B
//   ['D'],          //  / \
//   ['A', [         // D   A
//     ['C', [       //      \
//       ['E'],      //       C
//       ['F'],      //      / \
//     ]],           //     E   F
//   ]],

// ]];

// Подсказки

//     Другие примеры можно посмотреть в файле с тестами
//     Используйте функции из библиотеки lodash
//     Работа с иерархическими структурами данных

// @ts-check

import { sortTree } from '@hexlet/graphs';
import transform from '../transformer.js';

describe('transform', () => {
  describe('simple tree', () => {
    const tree = [
      'A',
      [
        ['B', [['D']]],
        ['C', [['E'], ['F']]],
      ],
    ];

    it('#simple test1', () => {
      const expected = ['B', [['A', [['C', [['E'], ['F']]]]], ['D']]];

      const actual = transform(tree, 'B');
      expect(sortTree(actual)).toEqual(expected);
    });
  });

  describe('hard tree', () => {
    const tree = [
      'A',
      [
        ['B', [['D', [['H']]], ['E']]],
        [
          'C',
          [
            [
              'F',
              [
                ['I', [['M']]],
                ['J', [['N'], ['O']]],
              ],
            ],
            ['G', [['K'], ['L']]],
          ],
        ],
      ],
    ];

    it('#hard test 1', () => {
      const expected = [
        'F',
        [
          [
            'C',
            [
              ['A', [['B', [['D', [['H']]], ['E']]]]],
              ['G', [['K'], ['L']]],
            ],
          ],
          ['I', [['M']]],
          ['J', [['N'], ['O']]],
        ],
      ];

      const actual = transform(tree, 'F');
      expect(sortTree(actual)).toEqual(expected);
    });

    it('#hard test 2', () => {
      const expected = [
        'I',
        [
          [
            'F',
            [
              [
                'C',
                [
                  ['A', [['B', [['D', [['H']]], ['E']]]]],
                  ['G', [['K'], ['L']]],
                ],
              ],
              ['J', [['N'], ['O']]],
            ],
          ],
          ['M'],
        ],
      ];

      const actual = transform(tree, 'I');
      expect(sortTree(actual)).toEqual(expected);
    });
  });
});
